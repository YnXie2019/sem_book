<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>4 Coefficients | Structural Equation Modeling in R for Ecology and Evolution</title>
  <meta name="description" content="4 Coefficients | Structural Equation Modeling in R for Ecology and Evolution">
  <meta name="generator" content="bookdown  and GitBook 2.6.7">

  <meta property="og:title" content="4 Coefficients | Structural Equation Modeling in R for Ecology and Evolution" />
  <meta property="og:type" content="book" />
  
  
  
  <meta name="github-repo" content="jslefche/sem_book" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="4 Coefficients | Structural Equation Modeling in R for Ecology and Evolution" />
  
  
  

<meta name="author" content="Jonathan Lefcheck">


<meta name="date" content="2019-03-17">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="local-estimation.html">
<link rel="next" href="categorical-variables.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Preface</a></li>
<li class="chapter" data-level="2" data-path="global-estimation.html"><a href="global-estimation.html"><i class="fa fa-check"></i><b>2</b> Global Estimation</a><ul>
<li class="chapter" data-level="2.1" data-path="global-estimation.html"><a href="global-estimation.html#what-is-covariance"><i class="fa fa-check"></i><b>2.1</b> What is (Co)variance?</a></li>
<li class="chapter" data-level="2.2" data-path="global-estimation.html"><a href="global-estimation.html#regression-coefficients"><i class="fa fa-check"></i><b>2.2</b> Regression Coefficients</a><ul>
<li class="chapter" data-level="2.2.1" data-path="global-estimation.html"><a href="global-estimation.html#rule-1-unspecified-relationships-among-exogenous-variables-are-simply-their-bivariate-correlations."><i class="fa fa-check"></i><b>2.2.1</b> Rule 1: Unspecified relationships among exogenous variables are simply their bivariate correlations.</a></li>
<li class="chapter" data-level="2.2.2" data-path="global-estimation.html"><a href="global-estimation.html#rule-2-when-two-variables-are-connected-by-a-single-path-the-coefficient-of-that-path-is-the-regression-coefficient."><i class="fa fa-check"></i><b>2.2.2</b> Rule 2: When two variables are connected by a single path, the coefficient of that path is the regression coefficient.</a></li>
<li class="chapter" data-level="2.2.3" data-path="global-estimation.html"><a href="global-estimation.html#rule-3-the-strength-of-a-compound-path-one-that-includes-multiple-links-is-the-product-of-the-individual-coefficients."><i class="fa fa-check"></i><b>2.2.3</b> Rule 3: The strength of a compound path (one that includes multiple links) is the product of the individual coefficients.</a></li>
<li class="chapter" data-level="2.2.4" data-path="global-estimation.html"><a href="global-estimation.html#rule-4.-when-variables-are-connected-by-more-than-one-pathway-each-pathway-is-the-partial-regression-coefficient."><i class="fa fa-check"></i><b>2.2.4</b> Rule 4. When variables are connected by more than one pathway, each pathway is the ‘partial’ regression coefficient.</a></li>
<li class="chapter" data-level="2.2.5" data-path="global-estimation.html"><a href="global-estimation.html#rule-5-errors-on-endogenous-variables-relate-the-unexplained-correlations-or-variances-arising-from-unmeasured-variables."><i class="fa fa-check"></i><b>2.2.5</b> Rule 5: Errors on endogenous variables relate the unexplained correlations or variances arising from unmeasured variables.</a></li>
<li class="chapter" data-level="2.2.6" data-path="global-estimation.html"><a href="global-estimation.html#rule-6-unanalyzed-residual-correlations-among-two-endogenous-variables-are-their-partial-correlations."><i class="fa fa-check"></i><b>2.2.6</b> Rule 6: Unanalyzed (residual) correlations among two endogenous variables are their partial correlations.</a></li>
<li class="chapter" data-level="2.2.7" data-path="global-estimation.html"><a href="global-estimation.html#rule-7-the-total-effect-one-variable-has-another-is-the-sum-of-its-direct-and-indirect-effects."><i class="fa fa-check"></i><b>2.2.7</b> Rule 7: The total effect one variable has another is the sum of its direct and indirect effects.</a></li>
<li class="chapter" data-level="2.2.8" data-path="global-estimation.html"><a href="global-estimation.html#rule-8-the-total-effect-including-undirected-paths-is-equivalent-to-the-total-correlation."><i class="fa fa-check"></i><b>2.2.8</b> Rule 8: The total effect (including undirected paths) is equivalent to the total correlation.</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="global-estimation.html"><a href="global-estimation.html#variance-based-structural-equation-modeling"><i class="fa fa-check"></i><b>2.3</b> Variance-based Structural Equation Modeling</a></li>
<li class="chapter" data-level="2.4" data-path="global-estimation.html"><a href="global-estimation.html#model-identifiability"><i class="fa fa-check"></i><b>2.4</b> Model Identifiability</a></li>
<li class="chapter" data-level="2.5" data-path="global-estimation.html"><a href="global-estimation.html#goodness-of-fit-measures"><i class="fa fa-check"></i><b>2.5</b> Goodness-of-fit Measures</a></li>
<li class="chapter" data-level="2.6" data-path="global-estimation.html"><a href="global-estimation.html#model-fitting-using-lavaan"><i class="fa fa-check"></i><b>2.6</b> Model Fitting Using <em>lavaan</em></a><ul>
<li class="chapter" data-level="2.6.1" data-path="global-estimation.html"><a href="global-estimation.html#lavaan-vs-lm"><i class="fa fa-check"></i><b>2.6.1</b> <em>lavaan</em> vs <code>lm</code></a></li>
<li class="chapter" data-level="2.6.2" data-path="global-estimation.html"><a href="global-estimation.html#sem-using-lavaan"><i class="fa fa-check"></i><b>2.6.2</b> SEM using <em>lavaan</em></a></li>
<li class="chapter" data-level="2.6.3" data-path="global-estimation.html"><a href="global-estimation.html#testing-alternate-structure-using-lavaan"><i class="fa fa-check"></i><b>2.6.3</b> Testing Alternate Structure using <em>lavaan</em></a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="global-estimation.html"><a href="global-estimation.html#references"><i class="fa fa-check"></i><b>2.7</b> References</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="local-estimation.html"><a href="local-estimation.html"><i class="fa fa-check"></i><b>3</b> Local Estimation</a><ul>
<li class="chapter" data-level="3.1" data-path="local-estimation.html"><a href="local-estimation.html#global-vs.local-estimation"><i class="fa fa-check"></i><b>3.1</b> Global vs. local estimation</a></li>
<li class="chapter" data-level="3.2" data-path="local-estimation.html"><a href="local-estimation.html#tests-of-directed-separation"><i class="fa fa-check"></i><b>3.2</b> Tests of directed separation</a></li>
<li class="chapter" data-level="3.3" data-path="local-estimation.html"><a href="local-estimation.html#model-fitting-using-piecewisesem"><i class="fa fa-check"></i><b>3.3</b> Model fitting using <em>piecewiseSEM</em></a></li>
<li class="chapter" data-level="3.4" data-path="local-estimation.html"><a href="local-estimation.html#shipley-2009-a-worked-example"><i class="fa fa-check"></i><b>3.4</b> Shipley (2009): A Worked Example</a></li>
<li class="chapter" data-level="3.5" data-path="local-estimation.html"><a href="local-estimation.html#a-special-case-where-graph-theory-fails"><i class="fa fa-check"></i><b>3.5</b> A Special Case: Where Graph Theory Fails</a></li>
<li class="chapter" data-level="3.6" data-path="local-estimation.html"><a href="local-estimation.html#references-1"><i class="fa fa-check"></i><b>3.6</b> References</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="coefficients.html"><a href="coefficients.html"><i class="fa fa-check"></i><b>4</b> Coefficients</a><ul>
<li class="chapter" data-level="4.1" data-path="coefficients.html"><a href="coefficients.html#unstandardized-and-standardized-coefficients"><i class="fa fa-check"></i><b>4.1</b> Unstandardized and Standardized Coefficients</a></li>
<li class="chapter" data-level="4.2" data-path="coefficients.html"><a href="coefficients.html#scale-standardization"><i class="fa fa-check"></i><b>4.2</b> Scale Standardization</a></li>
<li class="chapter" data-level="4.3" data-path="coefficients.html"><a href="coefficients.html#range-standardization"><i class="fa fa-check"></i><b>4.3</b> Range Standardization</a></li>
<li class="chapter" data-level="4.4" data-path="coefficients.html"><a href="coefficients.html#binomial-response-models"><i class="fa fa-check"></i><b>4.4</b> Binomial Response Models</a></li>
<li class="chapter" data-level="4.5" data-path="coefficients.html"><a href="coefficients.html#scaling-to-other-non-normal-distributions"><i class="fa fa-check"></i><b>4.5</b> Scaling to Other Non-Normal Distributions</a></li>
<li class="chapter" data-level="4.6" data-path="coefficients.html"><a href="coefficients.html#references-2"><i class="fa fa-check"></i><b>4.6</b> References</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="categorical-variables.html"><a href="categorical-variables.html"><i class="fa fa-check"></i><b>5</b> Categorical Variables</a><ul>
<li class="chapter" data-level="5.1" data-path="categorical-variables.html"><a href="categorical-variables.html#introduction-to-exogenous-categorical-variables"><i class="fa fa-check"></i><b>5.1</b> Introduction to Exogenous Categorical Variables</a></li>
<li class="chapter" data-level="5.2" data-path="categorical-variables.html"><a href="categorical-variables.html#exogenous-categorical-variables-as-marginal-means"><i class="fa fa-check"></i><b>5.2</b> Exogenous Categorical Variables as Marginal Means</a></li>
<li class="chapter" data-level="5.3" data-path="categorical-variables.html"><a href="categorical-variables.html#exogenous-categorical-variables-as-marginal-means-a-worked-example"><i class="fa fa-check"></i><b>5.3</b> Exogenous Categorical Variables as Marginal Means: A Worked Example</a></li>
<li class="chapter" data-level="5.4" data-path="categorical-variables.html"><a href="categorical-variables.html#endogenous-categorical-variables"><i class="fa fa-check"></i><b>5.4</b> Endogenous Categorical Variables</a></li>
<li class="chapter" data-level="5.5" data-path="categorical-variables.html"><a href="categorical-variables.html#references-3"><i class="fa fa-check"></i><b>5.5</b> References</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="multigroup-analysis.html"><a href="multigroup-analysis.html"><i class="fa fa-check"></i><b>6</b> Multigroup Analysis</a><ul>
<li class="chapter" data-level="6.1" data-path="multigroup-analysis.html"><a href="multigroup-analysis.html#introduction-to-multigroup-analysis"><i class="fa fa-check"></i><b>6.1</b> Introduction to Multigroup Analysis</a></li>
<li class="chapter" data-level="6.2" data-path="multigroup-analysis.html"><a href="multigroup-analysis.html#multigroup-analysis-using-global-estimation"><i class="fa fa-check"></i><b>6.2</b> Multigroup Analysis using Global Estimation</a></li>
<li class="chapter" data-level="6.3" data-path="multigroup-analysis.html"><a href="multigroup-analysis.html#multigroup-analysis-using-local-estimation"><i class="fa fa-check"></i><b>6.3</b> Multigroup Analysis Using Local Estimation</a></li>
<li class="chapter" data-level="6.4" data-path="multigroup-analysis.html"><a href="multigroup-analysis.html#grace-jutila-1999-a-worked-example"><i class="fa fa-check"></i><b>6.4</b> Grace &amp; Jutila (1999): A Worked Example</a></li>
<li class="chapter" data-level="6.5" data-path="multigroup-analysis.html"><a href="multigroup-analysis.html#references-4"><i class="fa fa-check"></i><b>6.5</b> References</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html"><i class="fa fa-check"></i><b>7</b> Latent Variable Modeling</a><ul>
<li class="chapter" data-level="7.1" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#introduction-to-latent-variable-modeling"><i class="fa fa-check"></i><b>7.1</b> Introduction to Latent Variable Modeling</a></li>
<li class="chapter" data-level="7.2" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#application-of-latent-variables-to-path-models"><i class="fa fa-check"></i><b>7.2</b> Application of Latent Variables to Path Models</a></li>
<li class="chapter" data-level="7.3" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#latent-variables-in-lavaan"><i class="fa fa-check"></i><b>7.3</b> Latent Variables in <em>lavaan</em></a></li>
<li class="chapter" data-level="7.4" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#multi-indicator-latent-variables"><i class="fa fa-check"></i><b>7.4</b> Multi-indicator Latent Variables</a></li>
<li class="chapter" data-level="7.5" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#confirmatory-factor-analysis"><i class="fa fa-check"></i><b>7.5</b> Confirmatory Factor Analysis</a></li>
<li class="chapter" data-level="7.6" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#travis-grace-2010-an-example"><i class="fa fa-check"></i><b>7.6</b> Travis &amp; Grace (2010): An Example</a></li>
<li class="chapter" data-level="7.7" data-path="latent-variable-modeling.html"><a href="latent-variable-modeling.html#references-5"><i class="fa fa-check"></i><b>7.7</b> References</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="composite-variables.html"><a href="composite-variables.html"><i class="fa fa-check"></i><b>8</b> Composite Variables</a><ul>
<li class="chapter" data-level="8.1" data-path="composite-variables.html"><a href="composite-variables.html#what-is-a-composite-variable"><i class="fa fa-check"></i><b>8.1</b> What is a Composite Variable?</a></li>
<li class="chapter" data-level="8.2" data-path="composite-variables.html"><a href="composite-variables.html#constructing-a-composite-variable"><i class="fa fa-check"></i><b>8.2</b> Constructing a Composite Variable</a></li>
<li class="chapter" data-level="8.3" data-path="composite-variables.html"><a href="composite-variables.html#grace-keeley-revisited-a-worked-example"><i class="fa fa-check"></i><b>8.3</b> Grace &amp; Keeley Revisited: A Worked Example</a></li>
<li class="chapter" data-level="8.4" data-path="composite-variables.html"><a href="composite-variables.html#composites-in-piecewisesem"><i class="fa fa-check"></i><b>8.4</b> Composites in <em>piecewiseSEM</em></a></li>
<li class="chapter" data-level="8.5" data-path="composite-variables.html"><a href="composite-variables.html#references-6"><i class="fa fa-check"></i><b>8.5</b> References</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Structural Equation Modeling in R for Ecology and Evolution</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="coefficients" class="section level1">
<h1><span class="header-section-number">4</span> Coefficients</h1>
<div id="unstandardized-and-standardized-coefficients" class="section level2">
<h2><span class="header-section-number">4.1</span> Unstandardized and Standardized Coefficients</h2>
<p>Path (or regression) coefficients are the inferential engine behind structural equation modeling, and by extension all of linear regression. They relate changes in the dependent variable <span class="math inline">\(y\)</span> to changes in the independent variable <span class="math inline">\(x\)</span>, and thus act as a measure of association. In fact, you may recall from the chapter on global estimation that, under specific circumstances, path coefficients can be expressed as (partial) correlations, a unitless measure of association that makes them excellent for comparisons. They also allow us to generate predictions for new values of <span class="math inline">\(x\)</span> and are therefore useful in testing and extrapolating model results.</p>
<p>We will consider two kinds of regression coefficients: unstandardized (or raw) coefficients, and standardized coefficients.</p>
<p>Unstandardized coefficients are the default values returned by all statistical programs. In short, they reflect the expected (linear) change in the response with each unit change in the predictor. For a coefficient value <span class="math inline">\(\beta = 0.5\)</span>, for example, a 1 unit change in <span class="math inline">\(x\)</span> there is, on average, an 0.5 unit change in <span class="math inline">\(y\)</span>.</p>
<p>In models with more than one independent variable (e.g., <span class="math inline">\(x1\)</span>, <span class="math inline">\(x2\)</span>, etc), the coefficient reflects the expected change in <span class="math inline">\(y\)</span> <em>given</em> the other variables in the model. This implies that the effect of one particular variable controls for the presence of other variables, generally by holding them constant at their mean. This is why such coefficients are referred to as <em>partial</em> regression coefficients, because they reflect the independent (or partial) contributions of any particular variable.</p>
<p>As an aside: one tricky aspect to interpretation involves transformations. When the log-transformation is applied, for example, the relationships between the variable are no longer linear. This means that we have to change our interpretation slightly. When <span class="math inline">\(y\)</span> is log-transformed, the coefficient <span class="math inline">\(\beta\)</span> is interpreted as a 1 unit change in <span class="math inline">\(x\)</span> leads to a <span class="math inline">\((exp(\beta) - 1) \times 100%\)</span> change in <span class="math inline">\(y\)</span>. Oppositely, when the independent variable <span class="math inline">\(x\)</span> is log-transformed, <span class="math inline">\(\beta\)</span> is interpreted as a 1% change in <span class="math inline">\(x\)</span> leads to a <span class="math inline">\(\beta\)</span> increase in <span class="math inline">\(y\)</span>. Finally, when both are transformed, both are expressed in percentages: a 1% change in <span class="math inline">\(x\)</span> leads to a <span class="math inline">\((exp(\beta) - 1) \times 100%\)</span> change in <span class="math inline">\(y\)</span>. Transformations often confound intrepretation, so it is worth mentioning.</p>
<p>In contrast to raw coefficients, standardized coefficients are expressed in equivalent units, regardless of the original measurements. Often these are in units of standard deviations of the mean (scale standardization) but, as we shall see shortly, there are other possibilities. The goal of standardization is to increase <em>comparability</em>. In other words, the magnitude of standardized coefficients can be directly compared to make inferences about the relative strength of relationships.</p>
<p>In SEM, it is often advised to report both unstandardized and standardized coefficients, because they present different and mutually exclusive information. Unstandardized coefficients contain information about both the variance <em>and</em> the mean, and thus are essential for prediction. Along these lines, they are also useful for comparing across models fit to the same variables, but using different sets of data. Because the most common form of standardization concerns scaling by the sample standard deviations, data derived from different sources (i.e., different datasets) have different sample variances and their standardized coefficients are not immediately comparable.</p>
<p>Unstandardized coefficients also reflect the phenomenon of interest in straightforward language. Imagine telling someone that 1 standard deviation change in nutrient input levels would result in a 6 standard deviation change in water quality. That might seem impressive until it becomes clear that the size of the dataset has reduced the sample variance, and the absoluty relationship reveals only a very tiny change in water quality with each unit change in nutrient levels. Not so impressive anymore.</p>
<p>Standardized effects, on the other hand, are useful for comparing the relative magnitude of change associated with different paths in the same model (i.e., using the same dataset). Care should be taken <em>not</em> to interpret these relationships as the ‘proportion of variance explained’–for example, a larger standardized coefficient does not explain more variance in the response than a smaller standardized coefficient–but rather in terms of relative influence on the mean of the response.</p>
<p>By extension, standardization is necessary to compare indirect or compound effects among different sets of paths in the same model: for example, comparing direct vs. indirect pathways in a partial mediation model. This is because those pathways could be measured in very different units, and their relative magnitudes might simply reflect their measurement units rather than any stronger or weaker explanatory power.</p>
<p>In contrast, comparing the strength of indirect or compound effects across the same path in different models <em>requires</em> unstandardized coefficients, due to the issue of different sample variances raised above. Comparing the same path across different models using standardized coefficients would require a demonstration that the sample variances are not significantly different (or alternately, that the entire population has been sampled).</p>
<p>Thus, both standardized and unstandardized coefficients have their place in structural equation modeling. Let’s now explore some of the different forms of standardization, and how they can be achieved.</p>
</div>
<div id="scale-standardization" class="section level2">
<h2><span class="header-section-number">4.2</span> Scale Standardization</h2>
<p>The most typical implementation of standardization is placing the coefficients in units of standard deviations of the mean. This is accomplished by scaling the coefficient <span class="math inline">\(\beta\)</span> by the ratio of the standard deviation of <span class="math inline">\(x\)</span> over the standard deviation of <span class="math inline">\(y\)</span>:</p>
<p><span class="math display">\[b = \beta*\left( \frac{sd_x}{sd_y} \right)\]</span></p>
<p>Thus lending this standardization its name. This coefficient has the interpretation that, for a 1 standard deviation change in <span class="math inline">\(x\)</span>, we expect a <span class="math inline">\(b\)</span> unit standard deviation change in <span class="math inline">\(y\)</span>.</p>
<p>This standardization can also be achieved by <em>Z</em>-transforming the raw data, in which case <span class="math inline">\(b\)</span> is already the (partial) correlation between <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</p>
<p>Both <em>lavaan</em> and <em>piecewiseSEM</em> return scale-standardized coefficients. <em>lavaan</em> requires a different set of functions or arguments, while <em>piecewiseSEM</em> will do it by default using the functions <code>coefs</code>. <code>coefs</code> has the added benefit in that it can be called on any model object, and thus has applications outside of structural equation modeling.</p>
<p>Let’s run an example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(lavaan)

<span class="kw">library</span>(piecewiseSEM)

<span class="kw">set.seed</span>(<span class="dv">6</span>)

data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">y =</span> <span class="kw">runif</span>(<span class="dv">100</span>), <span class="dt">x =</span> <span class="kw">runif</span>(<span class="dv">100</span>))

xy_model &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> data)

<span class="co"># perform manual standardization</span>
beta &lt;-<span class="st"> </span><span class="kw">summary</span>(xy_model)<span class="op">$</span>coefficients[<span class="dv">2</span>, <span class="dv">1</span>]

(beta_std &lt;-<span class="st"> </span>beta <span class="op">*</span><span class="st"> </span>(<span class="kw">sd</span>(data<span class="op">$</span>x)<span class="op">/</span><span class="kw">sd</span>(data<span class="op">$</span>y)))</code></pre></div>
<pre><code>## [1] 0.09456659</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># now retrieve with piecewiseSEM</span>
<span class="kw">coefs</span>(xy_model)</code></pre></div>
<pre><code>##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate
## 1        y         x   0.0922     0.098 98     0.9404  0.3493       0.0946
##   
## 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># and with lavaan</span>
xy_formula &lt;-<span class="st"> &#39;y ~ x&#39;</span>

xy_sem &lt;-<span class="st"> </span><span class="kw">sem</span>(xy_formula, data)

<span class="kw">standardizedsolution</span>(xy_sem)</code></pre></div>
<pre><code>##   lhs op rhs est.std    se      z pvalue ci.lower ci.upper
## 1   y  ~   x   0.095 0.099  0.956  0.339   -0.099    0.288
## 2   y ~~   y   0.991 0.019 52.991  0.000    0.954    1.028
## 3   x ~~   x   1.000 0.000     NA     NA    1.000    1.000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># also</span>
<span class="kw">summary</span>(xy_sem, <span class="dt">standardize =</span> T)</code></pre></div>
<pre><code>## lavaan 0.6-3 ended normally after 11 iterations
## 
##   Optimization method                           NLMINB
##   Number of free parameters                          2
## 
##   Number of observations                           100
## 
##   Estimator                                         ML
##   Model Fit Test Statistic                       0.000
##   Degrees of freedom                                 0
## 
## Parameter Estimates:
## 
##   Information                                 Expected
##   Information saturated (h1) model          Structured
##   Standard Errors                             Standard
## 
## Regressions:
##                    Estimate  Std.Err  z-value  P(&gt;|z|)   Std.lv  Std.all
##   y ~                                                                   
##     x                 0.092    0.097    0.950    0.342    0.092    0.095
## 
## Variances:
##                    Estimate  Std.Err  z-value  P(&gt;|z|)   Std.lv  Std.all
##    .y                 0.090    0.013    7.071    0.000    0.090    0.991</code></pre>
<p>In all 3 cases, we have achieved a scale-standardized coefficient of <span class="math inline">\(b = 0.095\)</span>. Thus, a 1 SD change in <span class="math inline">\(x\)</span> would result in a 0.095 SD change in <span class="math inline">\(y\)</span>.</p>
</div>
<div id="range-standardization" class="section level2">
<h2><span class="header-section-number">4.3</span> Range Standardization</h2>
<p>An alternative to scale standardization is <em>relevant range</em> standardization. This approach scales the coefficients over some relevant range. Typically this is the full range of the data, in which case <span class="math inline">\(\beta\)</span> can be standardized as follows:</p>
<p><span class="math display">\[b = \beta * \frac{max(x) - min(x)}{max(y) - min(y)}\]</span></p>
<p>The interpretation for the coefficient would then be the expected proportional shift in <span class="math inline">\(y\)</span> along its range given a full shift along the range of <span class="math inline">\(x\)</span>.</p>
<p>At first, this might seem like a strange form of standardization, but it has some powerful applications. For example, consider a binary predictor: 0 or 1. In such a case, the relevant range-standardized coefficient is the expected shift in <span class="math inline">\(y\)</span> given the transition from one state (0) to another (1). Or consider a management target such as decreasing nutrient runoff by 10%. Would reducing fertilizer application by 10% of its range yield a 10% reduction in runoff? Such expressions are necessarily the currency of applied questions.</p>
<p>Perhaps the best application of relevant ranges is in comparing coefficients within a model: rather than dealing in somewhat esoteric quantities of standard deviations, relevant range standardization simply asks which variable causes a greater shift in <span class="math inline">\(y\)</span> along its range. This is a much more digestable concept to most scientists. It may even provide a more fair comparison across the same paths fit to different datasets, if the ranges are roughly similar and/or encompassed in the others. Restricting the range may be a useful solution for comparing coefficients across models fit to different data, as long as the range doesn’t extend beyond that observed in any particular dataset.</p>
<p>For a worked example, we have now entered fully into the realm of <em>piecewiseSEM</em>–it does not appear as if <em>lavaan</em> has integrated this functionality a of yet. Let’s attempt to scale the results by hand, then compare to the output from <code>coefs</code> with the argument <code>standardize = &quot;range&quot;</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#by hand</span>
(beta_rr &lt;-<span class="st"> </span>beta <span class="op">*</span><span class="st"> </span>(<span class="kw">max</span>(data<span class="op">$</span>x) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(data<span class="op">$</span>x))<span class="op">/</span>(<span class="kw">max</span>(data<span class="op">$</span>y) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(data<span class="op">$</span>y)))</code></pre></div>
<pre><code>## [1] 0.09806703</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">coefs</span>(xy_model, <span class="dt">standardize =</span> <span class="st">&quot;range&quot;</span>)</code></pre></div>
<pre><code>##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate
## 1        y         x   0.0922     0.098 98     0.9404  0.3493       0.0981
##   
## 1</code></pre>
<p>In both cases, we obtain a <span class="math inline">\(b = 0.0981\)</span> suggesting that a full shift in <span class="math inline">\(x\)</span> along its range would only result in a shift of 10% along the range of <span class="math inline">\(y\)</span>.</p>
<p>Both scale and relevant range-standardization only apply when the response is normally-distributed. If not, we must make some assumptions in order to obtain standardized coefficients. Let’s start with binomial responses.</p>
</div>
<div id="binomial-response-models" class="section level2">
<h2><span class="header-section-number">4.4</span> Binomial Response Models</h2>
<p>Binomial responses are those that are binary (0, 1) such as success or failure, present or absent, and so on. What is unique about them is that they do not have a linear relationship with a predictor <span class="math inline">\(x\)</span>. Instead, they are best modeled using a sigmoidal curve. To demonstrate, let’s generate some data, fit a binary model, and plot the predicted relationship:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">44</span>)

x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">20</span>)

x &lt;-<span class="st"> </span>x[<span class="kw">order</span>(x)]

y &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">rbinom</span>(<span class="dv">10</span>, <span class="dv">1</span>, <span class="fl">0.8</span>), <span class="kw">rbinom</span>(<span class="dv">10</span>, <span class="dv">1</span>, <span class="fl">0.2</span>))

glm_model &lt;-<span class="st"> </span><span class="kw">glm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> <span class="kw">data.frame</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y), <span class="st">&quot;binomial&quot;</span>)

xpred &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="kw">min</span>(x), <span class="kw">max</span>(x), <span class="fl">0.01</span>)

ypred &lt;-<span class="st"> </span><span class="kw">predict</span>(glm_model, <span class="kw">list</span>(<span class="dt">x =</span> xpred), <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>)

<span class="kw">plot</span>(x, y)

<span class="kw">lines</span>(xpred, ypred)</code></pre></div>
<p><img src="04-Coefficients_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>Clearly these data are not linear, and modeling them as such would ignore the underlying process. Instead, as you can see, we fit them to a binomial distribution using a generalized linear model (GLM).</p>
<p>GLMs consist of three parts: (1) the random component, or the expected values of the response based on their underlying distribution, (2) the systematic component that represents the linear combination of predictors, and (3) the link function, which links the expected values of the response (random component) to the linear combination of predictors (systematic component).</p>
<p>Basically, the link functions take something inherently non-linear and attempts to linearize it. This can be shown by plotting the predictions on the link-scale:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ypred_link &lt;-<span class="st"> </span><span class="kw">predict</span>(glm_model, <span class="kw">list</span>(<span class="dt">x =</span> xpred), <span class="dt">type =</span> <span class="st">&quot;link&quot;</span>)

<span class="kw">plot</span>(xpred, ypred_link)</code></pre></div>
<p><img src="04-Coefficients_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>Note how the line is no longer sigmoidal, but straight!</p>
<p>For binomial responses, there are two kinds of link functions: logit and probit. We’ll focus on the logit link for now because it’s more common. With this link, the coefficients are in units of logits or the <em>log odds ratio</em>, which reflect the log of the probability of observing an outcome (1) relative to the probability of not observing it (0).</p>
<p>Often these coefficients are reverted to just the odds ratio by taking the exponent, which yields the proportional change in the probablity observing one outcome (1) with a unit change change in the predictor.</p>
<p>Say, for example, we have a coefficient <span class="math inline">\(\beta = -0.12\)</span>. A 1 unit change in <span class="math inline">\(x\)</span> would result in <span class="math inline">\(exp(-0.12) = 0.88 \times 100%\)</span> or 88% reduction in the odds of observing the outcome.</p>
<p>The problem is that (log) odds ratios themselves are not comparable across models, and it’s unclear how they might be standardized, since the coefficient is on the link (linear) scale, while the only variance we can compute is from the raw data, which is on the non-linear scale. Thus, we need to find some sway to obtain estimates of variance on the same scale as the coefficient.</p>
<p>One approach is to consider that for every value of <span class="math inline">\(x\)</span>, there is an underlying probability distribution of observing a 0 or a 1 for <span class="math inline">\(y\)</span>. The mean of these distributions is where a particular outcome is <em>most</em> likely. Let’s say at low values of <span class="math inline">\(x\)</span> we observe <span class="math inline">\(y = 0\)</span>, at at high values of <span class="math inline">\(x\)</span> we observe <span class="math inline">\(y = 1\)</span>. If we order <span class="math inline">\(x\)</span>, the mean probabilities give rise to a linear increase in observing <span class="math inline">\(y = 1\)</span> with increasing <span class="math inline">\(x\)</span>. Here is an illustration of this phenomenon (from Long 1997):</p>
<div class="figure">
<img src="https://raw.githubusercontent.com/jslefche/sem_book/master/img/coefficients_latent_propensity.png" />

</div>
<p>This linear but latent (i.e., unobserved) variable, which we call <span class="math inline">\(y^*\)</span>, is therefore related to the observed values of <span class="math inline">\(x\)</span> through a vector of linear coefficients <span class="math inline">\(\beta\)</span> as in any other linear model:</p>
<p><span class="math display">\[y^*_{i} = x_{i}\beta + \epsilon_{i}\]</span></p>
<p>The problem is, we can never observe this linear underlying or <em>latent propensity</em>, and so we must approximate it. At some value of <span class="math inline">\(x\)</span>, this probability is evenly split at 50/50: we call this cutpoint <span class="math inline">\(\tau\)</span>. Below <span class="math inline">\(\tau\)</span> we are more likely to observe 0 in our example, while above <span class="math inline">\(\tau\)</span> we are more likely to observe 1. We can relate <span class="math inline">\(y\)</span> to <span class="math inline">\(y^*\)</span> based on whether the observed values fall above or below this cutpoint.</p>
<p>Since latent variables are unobserved, we must also make some assumptions about their error variance. In a later chapter on Latent Variable Modeling, we often fixed their error variance to 1. In this case, there are theoretically-derived error variances depending on the distribution and the link function: for the probit link, the error variance <span class="math inline">\(\epsilon = 1\)</span>, while for the logit link, <span class="math inline">\(\epsilon = \pi^2/3\)</span>, both for the binomial distribution.</p>
<p>Regardless of the type of standardization, we need to know about the range or variance of the response. With our knowledge of <span class="math inline">\(y^*_{i}\)</span> and the theoretical error variances, we have all the information needed to compute the variance on the link (linear) scale.</p>
<p>The variance in <span class="math inline">\(y^*\)</span> is the sum of the variance of the predictions (on the linear scale) <em>plus</em> the theoretical error variance. For a logit link, then:</p>
<p><span class="math display">\[\sigma_{y^*_{i}}^2 = \sigma_{x\beta}^2 + \pi^2/3\]</span></p>
<p>The square-root of this quantity gives the standard deviation of <span class="math inline">\(SD_{y^*}\)</span> on the linear scale for use in scale standardization, or alternately, the range of <span class="math inline">\(y^*\)</span> to use in relevant range standardization.</p>
<p>There is an alternate method to the ‘latent theoretic approach’, which relies on the proportion of variance explained, or <span class="math inline">\(R^2\)</span>. Here, we can express the <span class="math inline">\(R^2\)</span> as the variance of the predicted values (on the non-linear scale) over the variance of the observed values (also on the non-linear scale):</p>
<p><span class="math display">\[R^2 = \frac{\sigma_{\hat{y}}^2}{\sigma_{y}^2}\]</span></p>
<p>We can obtain the variance of the observed values as the variance of the predicted values (on the linear scale) over the total explained variance of <span class="math inline">\(R^2\)</span>. The standard deviation, of course, is the square-root of this variance.</p>
<p>This method, called the <em>observation-empirical approach</em>, does not require the acknowledgement of any latent variables or theoretical error variances, but does require an acceptance of this is a valid measurement of <span class="math inline">\(R^2\)</span> (which some consider it not, as GLM estimation is based on deviance, not variance, and thus this statistic is not equivalent). It also does not provide a measure of the range of <span class="math inline">\(y\)</span> although we can assume, based on sampling theory, that is <span class="math inline">\(6 * \sigma_{y}\)</span>.</p>
<p>Let’s revisit our earlier GLM example and construct standardized coefficients:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get beta from model</span>
beta &lt;-<span class="st"> </span><span class="kw">summary</span>(glm_model)<span class="op">$</span>coefficients[<span class="dv">2</span>, <span class="dv">1</span>]

preds &lt;-<span class="st"> </span><span class="kw">predict</span>(glm_model, <span class="dt">type =</span> <span class="st">&quot;link&quot;</span>) <span class="co"># linear predictions</span>

<span class="co"># latent theoretic</span>
sd.ystar &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">var</span>(preds) <span class="op">+</span><span class="st"> </span>(pi<span class="op">^</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">3</span>) <span class="co"># for default logit-link</span>

beta_lt &lt;-<span class="st"> </span>beta <span class="op">*</span><span class="st"> </span><span class="kw">sd</span>(x)<span class="op">/</span>sd.ystar

<span class="co"># observation empirical</span>
R2 &lt;-<span class="st"> </span><span class="kw">cor</span>(y, <span class="kw">predict</span>(glm_model, <span class="dt">type =</span> <span class="st">&quot;response&quot;</span>))<span class="op">^</span><span class="dv">2</span> <span class="co"># non-linear predictions</span>

sd.yhat &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">var</span>(preds)<span class="op">/</span>R2)

beta_oe &lt;-<span class="st"> </span>beta <span class="op">*</span><span class="st"> </span><span class="kw">sd</span>(x)<span class="op">/</span>sd.yhat

<span class="co"># obtain using `coefs`</span>
<span class="kw">coefs</span>(glm_model, <span class="dt">standardize.type =</span> <span class="st">&quot;latent.linear&quot;</span>); beta_lt</code></pre></div>
<pre><code>##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate
## 1        y         x  -2.0975    0.9664 18    -2.1703    0.03      -0.8122
##    
## 1 *</code></pre>
<pre><code>## [1] -0.8121808</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">coefs</span>(glm_model, <span class="dt">standardize.type =</span> <span class="st">&quot;Menard.OE&quot;</span>); beta_oe</code></pre></div>
<pre><code>##   Response Predictor Estimate Std.Error DF Crit.Value P.Value Std.Estimate
## 1        y         x  -2.0975    0.9664 18    -2.1703    0.03      -0.6566
##    
## 1 *</code></pre>
<pre><code>## [1] -0.6565602</code></pre>
<p>We see that both approaches produce coefficients, and they are the same as returned by the <code>coefs</code> function in <em>piecewiseSEM</em> (with the appropriate argument).</p>
<p>You’ll note that the observation-empirical approach yields a smaller coefficient than the latent-theoretic. This is because the former approach is influenced by the fact that it is based on the relationship between a linear approximation (predictions) of a non-linear variable (raw values), introducing a loss of information. The <em>latent theoretic approach</em> also suffers from a loss of information from use of a distribution-specific but theoretically-derived error variance, which may or may not approach the true error variance (which is unknowable). Either way, both kinds of standardization are not without their drawbacks, but both provide potentially useful information in being able to compare linear and now <em>linearized</em> standardized coefficients.</p>
</div>
<div id="scaling-to-other-non-normal-distributions" class="section level2">
<h2><span class="header-section-number">4.5</span> Scaling to Other Non-Normal Distributions</h2>
<p>As it turns out, the latent-theoretic approach has one further benefit: we can extend it to other distributions (as they all have their own described theoretical error variances), and mixed-effects models that introduce another source of random variation.</p>
<p>[content to come]</p>
</div>
<div id="references-2" class="section level2">
<h2><span class="header-section-number">4.6</span> References</h2>
<p>Grace, J. B., Johnson, D. J., Lefcheck, J. S., &amp; Byrnes, J. E. (2018). Quantifying relative importance: computing standardized effects in models with binary outcomes. Ecosphere, 9(6), e02283.</p>
<p>Scott Long, J. (1997). Regression models for categorical and limited dependent variables. Advanced quantitative techniques in the social sciences, 7.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="local-estimation.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="categorical-variables.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
